import networkx as nx
import numpy as np


def getWSModel(N, k, p):
    """
    Generate a Watts-Strogatz model with N nodes, a mean degree of k and a rewiring probability of p.
    Type of model: according to the average path length.

    :param N: int. Number of nodes of the network.
    :param k: int. Mean degree of the network (even, 0 <= k < N).
    :param p: float. Rewiring probability (0. <= p <= 1.).

    :return: a networkx network generated by the Watts-Strogatz model.
    """

    # STEP 1: Check if parameters are valid
    if not 0 <= k <= N-1:  # Mean degree (value limits)
        raise ValueError("The mean degree (k) of a Watts-Strogatz model with " + str(N-1) + " nodes must be in the range"
                         " [0, " + str(N-1) + "). Given value: " + str(k))
    elif k % 2 != 0:  # Mean degree (even)
        raise ValueError("The mean degree (k) of a Watts-Strogatz model must be even. Given value: " + str(k))

    elif not 0. <= p <= 1.:  # Probability
        raise ValueError("p is a probability, so it must in the range [0., 1.]. Given value: " + str(p))

    # STEP 2: Generate the network
    graph = nx.empty_graph(n=N)  # Create an empty graph with N nodes

    # For each node u, generate k edges: k//2 wiring u with its clockwise nearest neighbors (clockwise_connections)
    # and another k//2 with its counter-clockwise nearest neighbors (counter_clockwise_connections)
    clockwise_connections = [(u, (u+distance) % N) for u in graph.nodes for distance in range(1, (k//2)+1)]
    counter_clockwise_connections = [(u, (u-distance) % N) for u in graph.nodes for distance in range(1, (k//2)+1)]

    # Add the previous edges (clockwise and counter-clockwise) to the network, generating a regular ring lattice
    graph.add_edges_from(ebunch_to_add=clockwise_connections + counter_clockwise_connections)

    # Iterate over each clockwise edge (connecting nodes (u,v)) of the regular ring lattice
    for u_of_edge, v_of_edge in clockwise_connections:
        # Check if the edge could be rewired with a probability p
        if np.random.uniform() <= p:
            # First, select the valid edges departing from node u (not self-loops nor multi-edges)
            valid_new_vs = np.arange(N, dtype=np.int)
            valid_new_vs = np.delete(arr=valid_new_vs, obj=list(graph.neighbors(u_of_edge)) + [u_of_edge])
            # Then, if there is some node v available, remove the actual (u,v) edge and rewire
            # it to a randomly chosen v from the set of valid ones (valid_new_vs)
            if len(valid_new_vs) > 0:
                graph.remove_edge(u=u_of_edge, v=v_of_edge)
                graph.add_edge(u_of_edge=u_of_edge, v_of_edge=np.random.choice(a=valid_new_vs))

    return graph
