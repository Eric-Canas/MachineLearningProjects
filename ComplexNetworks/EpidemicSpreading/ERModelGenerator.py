import networkx as nx
import numpy as np

from itertools import combinations


def getERModel_NK(N, K):
    """
    Generate an Erdós-Rényi model with N nodes and K edges.
    Type of model: according to a degree distribution.

    :param N: int. Number of nodes of the network.
    :param K: int. Number of edges of the network (0 <= K <= N(N-1)/2).

    :return: a networkx network generated by the Erdós-Rényi G(N,K) model.
    """

    # STEP 1: Check if parameters are valid
    if not 0 <= K <= (N*(N-1)//2):  # Number of edges
        raise ValueError("The number of edges (K) of a Erdós-Rényi model with " + str(N) + " nodes must be in the "
                        "range [0, " + str((N*(N-1))//2) + "]. Given value: " + str(K))

    # STEP 2: Generate the network
    graph = nx.empty_graph(n=N)  # Create an empty graph with N nodes

    # Iterate until the graph has K edges
    while graph.size() < K:
        # Generate a pair of nodes randomly
        (u, v) = np.random.randint(low=0, high=N, size=2)
        # Check if it is possible to generate an edge between those nodes (u, v)
        # (not self-loops nor multi-edges)
        if u != v and (not graph.has_edge(u=u, v=v)):
            # If possible, add that edge to the graph
            graph.add_edge(u_of_edge=u, v_of_edge=v)

    return graph


def getERModel_Np(N, p):
    """
    Generate an Erdós-Rényi model with N nodes and a probability p of each possible edge to exist.
    Type of model: according to a degree distribution.

    :param N: int. Number of nodes of the network
    :param p: float. Probability for each possible edge to exist (0. <= p <= 1.).

    :return: a networkx network generated by the Erdós-Rényi G(N,p) model.
    """

    # STEP 1: Check if parameters are valid
    if not 0. <= p <= 1.:  # Probability
        raise ValueError("p is a probability, so it must in the range [0., 1.]. Given value: " + str(p))

    # STEP 2: Generate the network
    graph = nx.empty_graph(n=N)  # Create an empty graph with N nodes

    # Iterate for each combination of pairs of nodes without replacement (i.e. [0,1,2] -> [(0,1),(0,2), (1,2)])
    for u, v in combinations(iterable=range(N), r=2):
        # Add an edge between those nodes with a probability p
        if np.random.uniform() <= p:
            graph.add_edge(u_of_edge=u, v_of_edge=v)

    return graph
