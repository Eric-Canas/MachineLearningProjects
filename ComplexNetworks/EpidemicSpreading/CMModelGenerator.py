import networkx as nx
import numpy as np

# Constants
DEGREE, PROBABILITY = 0, 1
max_iterations = 5000


def getCMModel(N, P_k, regenerate_accurate=True):
    """
    Generates a Configuration Model of N nodes and degree distribution P_k.
    Type of model: according to a degree distribution.
    :param N: int. Number of nodes of the network.
    :param P_k: ndarray of shape (n_degrees, 2) (*). Degree distribution of the network.
    :param regenerate_accurate: bool. Indicates if the algorithm must reorganize the degree distribution of the network
    from scratch after creating an invalid configuration [True] or not [False] (doing small changes trying to fix it).
    (*) It must have the form [[degree_0, p_0], [degree_1, p_1], ..., [degree_n, p_n]] and all the p_i must add 1,
    since they are probabilities.
    :return: a networkx network generated by the Configuration Model.
    """

    # STEP 1: Check if parameters are valid
    # Represent each probability as the cumulative sum of the previous probabilities so that they are
    # distributed in the range [0, 1] proportionally and can be interpreted as bins
    cum_dist = np.cumsum(P_k[:, PROBABILITY])
    if not np.isclose(cum_dist[-1], 1., rtol=1e-3):  # Degree distribution
        raise ValueError("The degree distribution (P_k) of a configuration model is a probability and it must add 1."
                         "Sum of probabilities: " + str(np.round(cum_dist[-1], decimals=3)))

    # STEP 2: Generate the network
    graph = nx.empty_graph(n=N)  # Create an empty graph with N nodes

    # Define the degrees of the N nodes according to the degree distribution P_k by iterating over each node and
    # generating a random uniform value to assign a degree (bin) of the degree distribution to that node
    node_degrees = [P_k[np.argmax(cum_dist >= np.random.uniform()), DEGREE] for _ in range(N)]

    # Try to get a valid configuration of the network, this is, even number of degrees and less nodes or equal edges
    # than the maximum allowed for a graph with N nodes. Maximum number of attempts = max_iterations
    attempts = 0  # Start counting the number of attempts
    while(np.sum(node_degrees) % 2 != 0) or ((np.sum(node_degrees)//2) > (N*(N-1)//2)):
        # Case 1: regenerate_accurate = True. Obtain a new degree distribution in the network
        if regenerate_accurate:
            node_degrees = [P_k[np.argmax(cum_dist >= np.random.uniform()), DEGREE] for _ in range(N)]
        # Case 2: regenerate_accurate = False.
        # Change the degree of a randomly selected node using the degree distribution P_k
        else:
            node_degrees[np.random.randint(0, len(node_degrees))] = \
                P_k[np.argmax(cum_dist >= np.random.uniform()), DEGREE]

        attempts += 1  # Add a new attempt
        # If the maximum number of attempts is reached, raise an error
        if attempts > max_iterations:
            raise ValueError("Impossible to generate a valid result in " + str(attempts) + " iterations."
                        "Current attempt size of network: " + str(int(np.sum(node_degrees))) + "."
                        " Max possible size for " + str(N) + " nodes: " + str((N*(N-1)//2)) + ".")

    # Define the array of stubs as an array of node IDs in which each node appears as many times as its degree.
    # These nodes are arranged by pairs so that we can later create the edges by connecting two random nodes
    stubs = np.concatenate([[node for _ in range(int(node_degrees[node]))] for node in range(N)]).reshape(-1, 2)

    # Iterate until there are stubs available or we have reached the maximum number of attempts
    while len(stubs) > 0 and attempts < max_iterations:
        # Shuffle the array of stubs to generate edges by connecting every two available nodes
        np.random.shuffle(stubs.reshape(-1))
        # Mark all edges as invalid at the beginning
        impossible_to_connect_pairs = np.ones(shape=len(stubs), dtype=np.bool)
        # Iterate over all the generated edges
        for i, (u, v) in enumerate(stubs):
            # Check if the edge is valid (not self-loops nor multi-edges).
            # If so, add it to the graph and remove it from the invalid list of edges
            if u != v and (not graph.has_edge(u=u, v=v)):
                graph.add_edge(u_of_edge=u, v_of_edge=v)
                impossible_to_connect_pairs[i] = False

        # Erase from the array of stubs those used in valid edges for the current iteration
        stubs = stubs[impossible_to_connect_pairs]
        attempts += 1  # Increase the number of attempts by one

    return graph