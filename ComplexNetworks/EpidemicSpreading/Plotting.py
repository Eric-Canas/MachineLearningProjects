import numpy as np
from matplotlib import pyplot as plt
from textwrap import wrap
import os

ROUNDS = 3

def plot_evolution_over_time_by_beta(betas, mu, p_0, path, model_definition=''):
    """
    Plots the evolutioin over time in function of beta, with mu and p_0 fixeds
    :param betas: Dictionary: with Keys beta and key the list of its p evolution over time
    :param mu: Spontaneous recovery probability.
    :param p_0: Starting infected population
    :return:
    """
    title = model_definition+' \n Evolution of the infection in function of beta \n μ - '+str(np.round(mu, decimals=ROUNDS))+\
            ' -- p_0 - '+str(np.round(p_0, decimals=ROUNDS))
    legend = ['β: '+str(np.round(beta, decimals=ROUNDS)) for beta in betas.keys()]

    for beta in betas.values():
        plt.plot(beta)

    plt.legend(legend)
    plt.xlabel('Time')
    plt.ylabel('P')
    plt.title(title)
    plt.savefig(os.path.join(path, title.replace('\n','')+'.png'))
    plt.close()

def plot_p_in_function_of_beta(ps, mu, p_0, t_stationary, path, model_definition=''):
    """
    Plots the evolutioin over time in function of beta, with mu and p_0 fixeds
    :param ps: Dictionary: with Keys beta and key the list of its p evolution over time
    :param mu: Spontaneous recovery probability.
    :param p_0: Starting infected population
    :return:
    """
    title = model_definition + '\n Mean Stationary P in Function of β \n' \
            ' μ - ' + str(np.round(mu, decimals=ROUNDS)) + ' -- p_0 - ' + str(np.round(p_0, decimals=ROUNDS))

    x = np.sort(list(ps.keys()))
    y = [np.mean(ps[beta][-t_stationary:]) for beta in x]

    plt.plot(x,y, color='coral'), plt.plot(x,y, 'o', color='coral')

    plt.xlabel('β')
    plt.ylabel('P')
    plt.ylim(0.,1.)
    plt.title(title)
    plt.savefig(os.path.join(path, title.replace('\n', '') + '.png'))
    plt.close()


def plot_degree_distribution(graph, bins=10, log_log=False, file=None, path=None, plot_histogram=None, calculate_gamma=True):
    """
    Plots (or saves) the Probability Degree Distribution (PDF) and the Complementary Cumulative Degree Distribution
    (CCDF) histograms in linear or log-log scale of the graph.
    :param bins: int. Number of bins to use in the histogram.
    :param log_log: bool. Apply log_log scale?
    :param file: String. Name of the file (If given, add it to the title of the plot).
    :param path: String. Location to store the plot generated by this function.
    :param plot_histogram: Histogram already computed to be plotted (for the theoretical results).
    """

    # Get the degrees of all the nodes in the graph
    degrees = np.array([d for _, d in graph.degree()])
    if calculate_gamma:
        # Calculate the gamma exponent of the degree distribution (using the MLE formula)
        gamma = 1 + len(degrees) * ((np.sum(np.log(degrees / (np.min(degrees) - 0.5)))) ** -1)

    # First, check if the degree distribution of the network must be represented as a Dirac delta function
    if degrees.min() == degrees.max():
        bins = np.arange(0, 2 * degrees.max())
    else:  # Divide the bins differently depending on the scale used
        if log_log:  # 10 bins for log-log scale
            bins = np.logspace(np.log10(degrees.min()), np.log10(degrees.max()), min(bins, degrees.max()))

        else:  # Same number of bins as the maximum number of degrees for linear scale
            bins = np.arange(degrees.min(), degrees.max())

    # Calculate the histogram with the given bins
    histogram, bins = np.histogram(degrees, bins=bins)

    # In case the 'theoretical' histogram is also provided (excluding Dirac delta function case)
    if plot_histogram is not None and degrees.min() != degrees.max():
        # Arrange it so that it contains the same bins that the equivalent histogram obtained during the
        # experimentation and therefore, both can be comparable
        histogram = [np.sum(plot_histogram[np.bitwise_and(plot_histogram[:, 0] > bins[bin - 1],
                                                          plot_histogram[:, 0] <= bins[bin]), 1]) for bin in
                     range(1, len(bins))]

    # Transform the histogram into a probability distribution (so that it adds 1)
    # With this, 'histogram' represents now the PDF plot
    histogram = histogram / np.sum(histogram)

    # Plot the PDF and the CCDF
    # CCDF is the complementary of CDD (1-CDD). CDD is the cumulative sum of the PDF
    for title in ('Probability Degree Distribution', 'Complementary Cumulative Degree Distribution'):
        if calculate_gamma:
            title += ". Gamma - " + str(np.round(gamma, decimals=3))  # Add the gamma value to the title

        # If we compute the CCDF, we have to modify the histogram to get the cumulative sum
        if 'Cumulative' in title:
            histogram = 1 - np.cumsum(histogram)

        # Choose the scale for the axes
        if log_log:  # Log-log scale
            # Set the width of the bins equal for all of them
            plt.bar(bins[1:], histogram, width=[bins[i] - bins[i - 1] for i in range(1, len(bins))])
            # Set the scale of x and y axes to log
            plt.xscale('log')
            plt.yscale('log')

        else:  # Linear scale
            plt.bar(bins[1:], histogram)

        if file is not None:  # Add the name of the network to the plot title if given
            title += ' (' + file + ')'

        # Plot titles and name of the axis
        plt.title("\n".join(wrap(title, 60)))
        plt.xlabel('Degree')
        plt.ylabel('Probability')

        # Show or save the plot
        plt.savefig(os.path.join(path, title + '.png'))

        plt.close()
